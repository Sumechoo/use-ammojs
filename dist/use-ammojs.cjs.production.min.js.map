{"version":3,"file":"use-ammojs.cjs.production.min.js","sources":["../src/physics/physics-context.tsx","../node_modules/regenerator-runtime/runtime.js","../src/utils/utils.ts","../src/physics/physics-provider.tsx","../src/physics/physics-api.tsx","../src/physics/physics-hooks.tsx"],"sourcesContent":["import { createContext, useContext } from \"react\";\nimport { Quaternion, Vector3 } from \"@react-three/fiber\";\nimport { Object3D } from \"three\";\nimport {\n  BodyConfig,\n  ConstraintType,\n  ShapeConfig,\n  UpdateBodyOptions,\n} from \"three-ammo\";\n\nexport interface ConstraintOptions {\n  type: ConstraintType;\n\n  pivot?: Vector3;\n  targetPivot?: Vector3;\n\n  axis?: Vector3;\n  targetAxis?: Vector3;\n}\n\nexport interface AmmoPhysicsContext {\n  addBody(uuid: string, mesh: Object3D, options?: BodyConfig);\n  removeBody(uuid: string);\n\n  addShapes(\n    bodyUuid: string,\n    shapesUuid: string,\n    mesh: Object3D,\n    options?: ShapeConfig\n  );\n  removeShapes(bodyUuid: string, shapesUuid: string);\n\n  addConstraint(\n    constraintId: string,\n    bodyUuid: string,\n    targetUuid: string,\n    options?: ConstraintOptions\n  );\n  removeConstraint(constraintId: string);\n\n  updateBody(uuid: string, options: UpdateBodyOptions);\n\n  enableDebug(enable: boolean, debugSharedArrayBuffer: SharedArrayBuffer);\n\n  resetDynamicBody(uuid: string);\n\n  activateBody(uuid: string);\n\n  bodySetMotionState(uuid: string, position?: Vector3, rotation?: Quaternion);\n  bodySetLinearVelocity(uuid: string, velocity: Vector3);\n  bodyApplyImpulse(uuid: string, impulse: Vector3, relativeOffset?: Vector3);\n  bodyApplyForce(uuid: string, force: Vector3, relativeOffset?: Vector3);\n\n  // Applies an (local) offset to all shapes of the rigidbody, without moving its origin\n  bodySetShapesOffset(uuid: string, offset: Vector3);\n\n  object3Ds: Record<string, Object3D>;\n}\n\nexport const AmmoPhysicsContext = createContext<AmmoPhysicsContext | null>(\n  null\n);\n\nexport function useAmmoPhysicsContext(): AmmoPhysicsContext {\n  const context = useContext(AmmoPhysicsContext);\n\n  if (!context) {\n    throw new Error(\n      \"Ammo Physics hook must be used within a <Physics /> Context\"\n    );\n  }\n\n  return context;\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import { AmmoDebugConstants } from \"ammo-debug-drawer\";\n\nexport function removeUndefinedKeys<T>(obj: T): T {\n  Object.keys(obj).forEach((key) => {\n    if (obj[key] === undefined) {\n      delete obj[key];\n    }\n  });\n  return obj;\n}\n\n// see AmmoDebugConstants from ammo-debug-drawer package\nexport interface AmmoDebugOptions {\n  DrawWireframe?: boolean;\n  DrawAabb?: boolean;\n  DrawFeaturesText?: boolean;\n  DrawContactPoints?: boolean;\n  NoDeactivation?: boolean;\n  NoHelpText?: boolean;\n  DrawText?: boolean;\n  ProfileTimings?: boolean;\n  EnableSatComparison?: boolean;\n  DisableBulletLCP?: boolean;\n  EnableCCD?: boolean;\n  DrawConstraints?: boolean;\n  DrawConstraintLimits?: boolean;\n  FastWireframe?: boolean;\n  DrawNormals?: boolean;\n  MAX_DEBUG_DRAW_MODE?: boolean;\n}\n\n// Converts the AmmoDebugOptions into a bitmasked integer that is used by bullet\nexport function ammoDebugOptionsToNumber(\n  debugOptions: AmmoDebugOptions\n): number {\n  let options = AmmoDebugConstants.NoDebug;\n\n  if (debugOptions.DrawWireframe) {\n    options |= AmmoDebugConstants.DrawWireframe;\n  }\n\n  if (debugOptions.DrawAabb) {\n    options |= AmmoDebugConstants.DrawAabb;\n  }\n\n  if (debugOptions.DrawFeaturesText) {\n    options |= AmmoDebugConstants.DrawFeaturesText;\n  }\n\n  if (debugOptions.NoHelpText) {\n    options |= AmmoDebugConstants.NoHelpText;\n  }\n\n  if (debugOptions.DrawText) {\n    options |= AmmoDebugConstants.DrawText;\n  }\n\n  if (debugOptions.ProfileTimings) {\n    options |= AmmoDebugConstants.ProfileTimings;\n  }\n\n  if (debugOptions.EnableSatComparison) {\n    options |= AmmoDebugConstants.EnableSatComparison;\n  }\n\n  if (debugOptions.DisableBulletLCP) {\n    options |= AmmoDebugConstants.DisableBulletLCP;\n  }\n\n  if (debugOptions.EnableCCD) {\n    options |= AmmoDebugConstants.EnableCCD;\n  }\n\n  if (debugOptions.DrawConstraints) {\n    options |= AmmoDebugConstants.DrawConstraints;\n  }\n\n  if (debugOptions.DrawConstraintLimits) {\n    options |= AmmoDebugConstants.DrawConstraintLimits;\n  }\n\n  if (debugOptions.FastWireframe) {\n    options |= AmmoDebugConstants.FastWireframe;\n  }\n\n  if (debugOptions.DrawNormals) {\n    options |= AmmoDebugConstants.DrawNormals;\n  }\n\n  if (debugOptions.MAX_DEBUG_DRAW_MODE) {\n    options |= AmmoDebugConstants.MAX_DEBUG_DRAW_MODE;\n  }\n\n  return options;\n}\n","import {\n  BodyConfig,\n  CONSTANTS,\n  ShapeConfig,\n  UpdateBodyOptions,\n  WorkerHelpers,\n  WorldConfig,\n} from \"three-ammo\";\nimport { createAmmoWorker } from \"three-ammo/dist/threeammo-worker\";\nimport {\n  BufferAttribute,\n  BufferGeometry,\n  DynamicDrawUsage,\n  Matrix4,\n  Object3D,\n  Vector3,\n} from \"three\";\nimport React, { PropsWithChildren, useEffect, useState } from \"react\";\nimport { useFrame } from \"@react-three/fiber\";\nimport { DefaultBufferSize } from \"ammo-debug-drawer\";\nimport { AmmoPhysicsContext, ConstraintOptions } from \"./physics-context\";\nimport {\n  removeUndefinedKeys,\n  ammoDebugOptionsToNumber,\n  AmmoDebugOptions,\n} from \"../utils/utils\";\n\ninterface AmmoPhysicsProps {\n  // Draw a collision debug mesh into the scene\n  drawDebug?: boolean;\n\n  // Configures the debug options (not all options are tested)\n  drawDebugMode?: AmmoDebugOptions;\n\n  // default = [0, -9.8, 0]\n  gravity?: [number, number, number];\n\n  // default = 10e-6\n  epsilon?: number;\n\n  // default = 1/60\n  fixedTimeStep?: number;\n\n  // default = 4\n  maxSubSteps?: number;\n\n  // default = 10\n  solverIterations?: number;\n}\n\ninterface PhysicsState {\n  workerHelpers: ReturnType<typeof WorkerHelpers>;\n  debugGeometry: BufferGeometry;\n  debugSharedArrayBuffer: SharedArrayBuffer;\n  bodyOptions: Record<string, BodyConfig>;\n  uuids: string[];\n  headerIntArray: Int32Array;\n  object3Ds: Record<string, Object3D>;\n  objectMatricesFloatArray: Float32Array;\n  uuidToIndex: Record<string, number>;\n  debugIndex: Uint32Array;\n  addBody(uuid: string, mesh: Object3D, options?: BodyConfig);\n  updateBody(uuid: string, options: UpdateBodyOptions);\n  removeBody(uuid: string);\n  addShapes(\n    bodyUuid: string,\n    shapesUuid: string,\n    mesh: Object3D,\n    options?: ShapeConfig\n  );\n  addConstraint(\n    constraintId: string,\n    bodyUuid: string,\n    targetUuid: string,\n    options?: ConstraintOptions\n  );\n}\n\nconst DEFAULT_DEBUG_MODE = { DrawWireframe: true };\n\nexport function Physics({\n  drawDebug,\n  drawDebugMode = DEFAULT_DEBUG_MODE,\n  gravity,\n  epsilon,\n  fixedTimeStep,\n  maxSubSteps,\n  solverIterations,\n  children,\n}: PropsWithChildren<AmmoPhysicsProps>) {\n  const [physicsState, setPhysicsState] = useState<PhysicsState>();\n\n  useEffect(() => {\n    const uuids: string[] = [];\n    const object3Ds: Record<string, Object3D> = {};\n    const uuidToIndex: Record<string, number> = {};\n    const IndexToUuid: Record<number, string> = {};\n    const bodyOptions: Record<string, BodyConfig> = {};\n\n    const ammoWorker: Worker = createAmmoWorker();\n\n    const workerHelpers = WorkerHelpers(ammoWorker);\n\n    const sharedArrayBuffer = new SharedArrayBuffer(\n      4 * CONSTANTS.BUFFER_CONFIG.HEADER_LENGTH + //header\n        4 *\n          CONSTANTS.BUFFER_CONFIG.BODY_DATA_SIZE *\n          CONSTANTS.BUFFER_CONFIG.MAX_BODIES + //matrices\n        4 * CONSTANTS.BUFFER_CONFIG.MAX_BODIES //velocities\n    );\n    const headerIntArray = new Int32Array(\n      sharedArrayBuffer,\n      0,\n      CONSTANTS.BUFFER_CONFIG.HEADER_LENGTH\n    );\n    const objectMatricesIntArray = new Int32Array(\n      sharedArrayBuffer,\n      CONSTANTS.BUFFER_CONFIG.HEADER_LENGTH * 4,\n      CONSTANTS.BUFFER_CONFIG.BODY_DATA_SIZE *\n        CONSTANTS.BUFFER_CONFIG.MAX_BODIES\n    );\n    const objectMatricesFloatArray = new Float32Array(\n      sharedArrayBuffer,\n      CONSTANTS.BUFFER_CONFIG.HEADER_LENGTH * 4,\n      CONSTANTS.BUFFER_CONFIG.BODY_DATA_SIZE *\n        CONSTANTS.BUFFER_CONFIG.MAX_BODIES\n    );\n\n    objectMatricesIntArray[0] = CONSTANTS.BUFFER_STATE.UNINITIALIZED;\n\n    const debugSharedArrayBuffer = new SharedArrayBuffer(\n      4 + 2 * DefaultBufferSize * 4\n    );\n    const debugIndex = new Uint32Array(debugSharedArrayBuffer, 0, 4);\n    const debugVertices = new Float32Array(\n      debugSharedArrayBuffer,\n      4,\n      DefaultBufferSize\n    );\n    const debugColors = new Float32Array(\n      debugSharedArrayBuffer,\n      4 + DefaultBufferSize,\n      DefaultBufferSize\n    );\n    const debugGeometry = new BufferGeometry();\n    debugGeometry.setAttribute(\n      \"position\",\n      new BufferAttribute(debugVertices, 3).setUsage(DynamicDrawUsage)\n    );\n    debugGeometry.setAttribute(\n      \"color\",\n      new BufferAttribute(debugColors, 3).setUsage(DynamicDrawUsage)\n    );\n\n    ammoWorker.postMessage({\n      type: CONSTANTS.MESSAGE_TYPES.INIT,\n      worldConfig: removeUndefinedKeys({\n        debugDrawMode: ammoDebugOptionsToNumber(drawDebugMode),\n        gravity: gravity && new Vector3(gravity[0], gravity[1], gravity[2]),\n        epsilon,\n        fixedTimeStep,\n        maxSubSteps,\n        solverIterations,\n      } as WorldConfig),\n      sharedArrayBuffer,\n    });\n\n    const workerInitPromise = new Promise<PhysicsState>((resolve) => {\n      ammoWorker.onmessage = async (event) => {\n        if (event.data.type === CONSTANTS.MESSAGE_TYPES.READY) {\n          resolve({\n            workerHelpers,\n            debugGeometry,\n            debugSharedArrayBuffer,\n            bodyOptions,\n            uuids,\n            headerIntArray,\n            object3Ds,\n            objectMatricesFloatArray,\n            uuidToIndex,\n            debugIndex,\n            addBody,\n            removeBody,\n            addConstraint,\n            addShapes,\n            updateBody,\n          });\n        } else if (event.data.type === CONSTANTS.MESSAGE_TYPES.BODY_READY) {\n          const uuid = event.data.uuid;\n          uuids.push(uuid);\n          uuidToIndex[uuid] = event.data.index;\n          IndexToUuid[event.data.index] = uuid;\n        }\n      };\n    });\n\n    workerInitPromise.then(setPhysicsState);\n\n    function addBody(uuid, mesh, options: BodyConfig = {}) {\n      removeUndefinedKeys(options);\n\n      bodyOptions[uuid] = options;\n      object3Ds[uuid] = mesh;\n      workerHelpers.addBody(uuid, mesh, options);\n    }\n\n    function updateBody(uuid: string, options: UpdateBodyOptions) {\n      removeUndefinedKeys(options);\n\n      workerHelpers.updateBody(uuid, options);\n    }\n\n    function removeBody(uuid: string) {\n      uuids.splice(uuids.indexOf(uuid), 1);\n      delete IndexToUuid[uuidToIndex[uuid]];\n      delete uuidToIndex[uuid];\n      delete bodyOptions[uuid];\n      delete object3Ds[uuid];\n      workerHelpers.removeBody(uuid);\n    }\n\n    function addShapes(\n      bodyUuid: string,\n      shapesUuid: string,\n      mesh: Object3D,\n      options?: ShapeConfig\n    ) {\n      removeUndefinedKeys(options);\n\n      workerHelpers.addShapes(bodyUuid, shapesUuid, mesh, options);\n    }\n\n    function addConstraint(\n      constraintId: string,\n      bodyUuid: string,\n      targetUuid: string,\n      options?: ConstraintOptions\n    ) {\n      removeUndefinedKeys(options);\n\n      workerHelpers.addConstraint(constraintId, bodyUuid, targetUuid, options);\n    }\n\n    return () => {\n      ammoWorker.terminate();\n      setPhysicsState(undefined);\n    };\n  }, []);\n\n  useFrame(() => {\n    const transform = new Matrix4();\n    const inverse = new Matrix4();\n    const matrix = new Matrix4();\n    const scale = new Vector3();\n\n    if (!physicsState) {\n      return;\n    }\n\n    const {\n      workerHelpers,\n      debugGeometry,\n      bodyOptions,\n      uuids,\n      headerIntArray,\n      object3Ds,\n      objectMatricesFloatArray,\n      uuidToIndex,\n      debugIndex,\n    } = physicsState;\n\n    if (Atomics.load(headerIntArray, 0) === CONSTANTS.BUFFER_STATE.READY) {\n      for (let i = 0; i < uuids.length; i++) {\n        const uuid = uuids[i];\n        const type = bodyOptions[uuid].type\n          ? bodyOptions[uuid].type\n          : CONSTANTS.TYPE.DYNAMIC;\n        const object3D = object3Ds[uuid];\n        if (type === CONSTANTS.TYPE.DYNAMIC) {\n          matrix.fromArray(\n            objectMatricesFloatArray,\n            uuidToIndex[uuid] * CONSTANTS.BUFFER_CONFIG.BODY_DATA_SIZE\n          );\n          inverse.copy(object3D.parent!.matrixWorld).invert();\n          transform.multiplyMatrices(inverse, matrix);\n          transform.decompose(object3D.position, object3D.quaternion, scale);\n        } else {\n          objectMatricesFloatArray.set(\n            object3D.matrixWorld.elements,\n            uuidToIndex[uuid] * CONSTANTS.BUFFER_CONFIG.BODY_DATA_SIZE\n          );\n        }\n\n        // print velocities\n        // console.log(\n        //   uuid,\n        //   objectMatricesFloatArray[indexes[uuid] * BUFFER_CONFIG.BODY_DATA_SIZE + 16],\n        //   objectMatricesFloatArray[indexes[uuid] * BUFFER_CONFIG.BODY_DATA_SIZE + 17]\n        // );\n\n        // print coliisions\n        // const collisions = [];\n        // for (let j = 18; j < 26; j++) {\n        //   const collidingIndex = objectMatricesIntArray[uuidToIndex[uuid] * BUFFER_CONFIG.BODY_DATA_SIZE + j];\n        //   if (collidingIndex !== -1) {\n        //     collisions.push(IndexToUuid[collidingIndex]);\n        //   }\n        // }\n        // console.log(uuid, collisions);\n      }\n      Atomics.store(headerIntArray, 0, CONSTANTS.BUFFER_STATE.CONSUMED);\n    }\n\n    /* DEBUG RENDERING */\n    const index = Atomics.load(debugIndex, 0);\n    if (!!index) {\n      debugGeometry.attributes.position.needsUpdate = true;\n      debugGeometry.attributes.color.needsUpdate = true;\n      debugGeometry.setDrawRange(0, index);\n    }\n    Atomics.store(debugIndex, 0, 0);\n  });\n\n  useEffect(() => {\n    if (physicsState) {\n      if (drawDebug) {\n        workerHelpers.enableDebug(true, physicsState.debugSharedArrayBuffer);\n      } else {\n        workerHelpers.enableDebug(false, physicsState.debugSharedArrayBuffer);\n      }\n    }\n  }, [drawDebug, physicsState]);\n\n  if (!physicsState) {\n    return null;\n  }\n\n  const { workerHelpers, debugGeometry } = physicsState;\n\n  return (\n    <AmmoPhysicsContext.Provider\n      value={{\n        ...workerHelpers,\n\n        // workerHelpers Overrides\n        addBody: physicsState.addBody,\n        removeBody: physicsState.removeBody,\n        addShapes: physicsState.addShapes,\n        addConstraint: physicsState.addConstraint,\n        updateBody: physicsState.updateBody,\n\n        object3Ds: physicsState.object3Ds,\n      }}\n    >\n      {drawDebug && (\n        <lineSegments\n          geometry={debugGeometry}\n          frustumCulled={false}\n          renderOrder={999}\n        >\n          <lineBasicMaterial\n            attach=\"material\"\n            vertexColors={true}\n            depthTest={true}\n          />\n        </lineSegments>\n      )}\n      {children}\n    </AmmoPhysicsContext.Provider>\n  );\n}\n","import { AmmoPhysicsContext } from \"./physics-context\";\nimport { Vector3, Quaternion } from \"three\";\nimport { UpdateBodyOptions } from \"three-ammo\";\n\nexport interface PhysicsApi {\n  updateBodyOptions(options: UpdateBodyOptions): void;\n\n  getPosition(): Vector3;\n  setPosition(position: Vector3);\n\n  getRotation(): Quaternion;\n  setRotation(rotation: Quaternion);\n\n  setMotionState(position: Vector3, rotation: Quaternion): void;\n  setLinearVelocity(velocity: Vector3): void;\n\n  applyImpulse(impulse: Vector3, relativeOffset?: Vector3): void;\n  applyForce(force: Vector3, relativeOffset?: Vector3): void;\n\n  setShapesOffset(offset: Vector3);\n}\n\nexport function createPhysicsApi(\n  physicsContext: AmmoPhysicsContext,\n  bodyUUID: string,\n  shapesUUID: string\n) {\n  return {\n    updateBodyOptions(options: UpdateBodyOptions) {\n      physicsContext.updateBody(bodyUUID, options);\n    },\n\n    getPosition(): Vector3 {\n      return physicsContext.object3Ds[bodyUUID].position;\n    },\n\n    setPosition(position: Vector3) {\n      physicsContext.bodySetMotionState(bodyUUID, position);\n    },\n\n    getRotation(): Quaternion {\n      return physicsContext.object3Ds[bodyUUID].quaternion;\n    },\n\n    setRotation(rotation: Quaternion) {\n      physicsContext.bodySetMotionState(bodyUUID, undefined, rotation);\n    },\n\n    setMotionState(position: Vector3, rotation: Quaternion) {\n      physicsContext.bodySetMotionState(bodyUUID, position, rotation);\n    },\n\n    setLinearVelocity(velocity: Vector3) {\n      physicsContext.bodySetLinearVelocity(bodyUUID, velocity);\n    },\n\n    applyImpulse(impulse: Vector3, relativeOffset?: Vector3) {\n      physicsContext.bodyApplyImpulse(bodyUUID, impulse, relativeOffset);\n    },\n\n    applyForce(force: Vector3, relativeOffset?: Vector3) {\n      physicsContext.bodyApplyForce(bodyUUID, force, relativeOffset);\n    },\n\n    setShapesOffset(offset: Vector3) {\n      physicsContext.bodySetShapesOffset(bodyUUID, offset);\n    },\n  };\n}\n","import { MathUtils, Object3D } from \"three\";\nimport React, { MutableRefObject, useEffect, useRef, useState } from \"react\";\nimport { useAmmoPhysicsContext } from \"./physics-context\";\nimport { createPhysicsApi, PhysicsApi } from \"./physics-api\";\nimport { BodyConfig, BodyType, ShapeConfig, ShapeType } from \"three-ammo\";\n\ntype UsePhysicsOptions = Omit<BodyConfig, \"type\"> & {\n  shapeType: ShapeType;\n  bodyType?: BodyType;\n\n  // Overrides the physics shape. If not defined the referenced object3Ds mesh will be used. Origins must match.\n  mesh?: Object3D;\n\n  // use for manual overrides with the physics shape.\n  shapeConfig?: Omit<ShapeConfig, \"type\">;\n\n  position?: [number, number, number];\n};\n\nexport function usePhysics(\n  options: UsePhysicsOptions | (() => UsePhysicsOptions),\n  object3D?: Object3D\n): [MutableRefObject<Object3D>, PhysicsApi] {\n  const ref = useRef<Object3D>();\n\n  const physicsContext = useAmmoPhysicsContext();\n  const { addBody, addShapes, removeBody } = physicsContext;\n\n  const [bodyUUID] = useState(() => MathUtils.generateUUID());\n  const [shapesUUID] = useState(() => MathUtils.generateUUID());\n\n  useEffect(() => {\n    const objectToUse = object3D ? object3D : ref.current!;\n\n    if (typeof options === \"function\") {\n      options = options();\n    }\n    const {\n      bodyType,\n      shapeType,\n      shapeConfig,\n      position,\n      mesh,\n      ...rest\n    } = options;\n\n    if (position) {\n      objectToUse.position.set(position[0], position[1], position[2]);\n      objectToUse.updateMatrixWorld();\n    }\n\n    addBody(bodyUUID, objectToUse, { type: bodyType, ...rest });\n\n    const meshToUse = mesh ? mesh : objectToUse;\n\n    addShapes(bodyUUID, shapesUUID, meshToUse, {\n      type: shapeType,\n      ...shapeConfig,\n    });\n\n    return () => {\n      removeBody(bodyUUID);\n    };\n  }, []);\n\n  return [ref, createPhysicsApi(physicsContext, bodyUUID, shapesUUID)];\n}\n"],"names":["AmmoPhysicsContext","createContext","useAmmoPhysicsContext","context","useContext","Error","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","Context","_invoke","state","method","arg","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","removeUndefinedKeys","DEFAULT_DEBUG_MODE","DrawWireframe","createPhysicsApi","physicsContext","bodyUUID","shapesUUID","updateBodyOptions","options","updateBody","getPosition","object3Ds","position","setPosition","bodySetMotionState","getRotation","quaternion","setRotation","rotation","setMotionState","setLinearVelocity","velocity","bodySetLinearVelocity","applyImpulse","impulse","relativeOffset","bodyApplyImpulse","applyForce","force","bodyApplyForce","setShapesOffset","offset","bodySetShapesOffset","drawDebug","drawDebugMode","gravity","epsilon","fixedTimeStep","maxSubSteps","solverIterations","children","useState","physicsState","setPhysicsState","useEffect","uuids","uuidToIndex","bodyOptions","ammoWorker","createAmmoWorker","workerHelpers","WorkerHelpers","sharedArrayBuffer","SharedArrayBuffer","CONSTANTS","BUFFER_CONFIG","HEADER_LENGTH","BODY_DATA_SIZE","MAX_BODIES","headerIntArray","Int32Array","objectMatricesIntArray","objectMatricesFloatArray","Float32Array","BUFFER_STATE","UNINITIALIZED","debugOptions","debugSharedArrayBuffer","DefaultBufferSize","debugIndex","Uint32Array","debugVertices","debugColors","debugGeometry","BufferGeometry","addBody","uuid","mesh","removeBody","splice","indexOf","addShapes","bodyUuid","shapesUuid","addConstraint","constraintId","targetUuid","setAttribute","BufferAttribute","setUsage","DynamicDrawUsage","postMessage","MESSAGE_TYPES","INIT","worldConfig","debugDrawMode","AmmoDebugConstants","NoDebug","DrawAabb","DrawFeaturesText","NoHelpText","DrawText","ProfileTimings","EnableSatComparison","DisableBulletLCP","EnableCCD","DrawConstraints","DrawConstraintLimits","FastWireframe","DrawNormals","MAX_DEBUG_DRAW_MODE","Vector3","onmessage","event","data","READY","BODY_READY","index","terminate","useFrame","transform","Matrix4","inverse","matrix","scale","Atomics","load","object3D","TYPE","DYNAMIC","fromArray","copy","parent","matrixWorld","invert","multiplyMatrices","decompose","set","elements","store","CONSUMED","attributes","needsUpdate","color","setDrawRange","enableDebug","React","Provider","geometry","frustumCulled","renderOrder","attach","vertexColors","depthTest","ref","useRef","MathUtils","generateUUID","objectToUse","current","bodyType","shapeType","shapeConfig","rest","updateMatrixWorld"],"mappings":"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"}